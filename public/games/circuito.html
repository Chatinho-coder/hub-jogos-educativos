<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>âš¡ Circuito LÃ³gico</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  :root{--bg:#0f172a;--card:#1e293b;--accent:#38bdf8;--on:#22c55e;--off:#64748b;--wire:#334155;--wire-on:#38bdf8;--text:#f1f5f9;--muted:#94a3b8}
  body{font-family:'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--text);min-height:100dvh;display:flex;flex-direction:column;align-items:center;overflow-x:hidden}
  h1{font-size:1.5rem;margin:1rem 0 .25rem;text-align:center}
  h1 span{color:var(--accent)}
  .subtitle{color:var(--muted);font-size:.85rem;margin-bottom:.75rem;text-align:center}

  /* Top bar */
  .topbar{display:flex;gap:1rem;align-items:center;justify-content:center;margin-bottom:.5rem;flex-wrap:wrap}
  .topbar .badge{background:var(--card);padding:.35rem .75rem;border-radius:8px;font-size:.85rem;display:flex;align-items:center;gap:.35rem}
  .topbar .badge .icon{font-size:1rem}

  /* Circuit area */
  .circuit-wrap{position:relative;width:min(95vw,480px);aspect-ratio:4/3;background:var(--card);border-radius:16px;border:2px solid #334155;overflow:hidden;margin-bottom:.75rem}
  .circuit-wrap canvas{width:100%;height:100%}

  /* Gate legend */
  .legend{display:flex;gap:.5rem;flex-wrap:wrap;justify-content:center;margin-bottom:.5rem}
  .legend .chip{background:var(--card);padding:.25rem .6rem;border-radius:6px;font-size:.75rem;border:1px solid #334155}

  /* Switches row */
  .switches{display:flex;gap:1rem;justify-content:center;margin-bottom:.75rem;flex-wrap:wrap}
  .switch-group{display:flex;flex-direction:column;align-items:center;gap:.35rem}
  .switch-label{font-size:.8rem;color:var(--muted);font-weight:600}
  .switch-btn{width:64px;height:64px;border-radius:16px;border:3px solid var(--off);background:var(--card);font-size:1.8rem;font-weight:bold;cursor:pointer;transition:all .15s;display:flex;align-items:center;justify-content:center;color:var(--off);user-select:none;-webkit-tap-highlight-color:transparent}
  .switch-btn.on{border-color:var(--on);color:var(--on);background:#14532d22;box-shadow:0 0 20px #22c55e44}
  .switch-btn.indeterminate{border-color:#94a3b8;color:#94a3b8;background:#0f172a66}
  .switch-btn:active{transform:scale(.92)}

  /* Output */
  .output-row{display:flex;align-items:center;justify-content:center;gap:.5rem;margin-bottom:.5rem}
  .bulb{font-size:2.5rem;transition:all .3s}
  .bulb.lit{filter:drop-shadow(0 0 16px #fbbf24);animation:pulse-glow 1s ease-in-out infinite alternate}
  .output-label{font-size:1rem;font-weight:600}
  .output-label.on{color:var(--on)}
  .output-label.off{color:var(--off)}
  .target-badge{font-size:.85rem;padding:.2rem .5rem;border-radius:8px;background:#1e293b;border:1px solid #334155;color:var(--muted);margin-left:.25rem}

  @keyframes pulse-glow{from{filter:drop-shadow(0 0 12px #fbbf24)}to{filter:drop-shadow(0 0 24px #fbbf24)}}

  /* Goal hint */
  .goal{text-align:center;font-size:.85rem;color:var(--muted);margin-bottom:.75rem;padding:0 1rem;min-height:2.5em}
  .goal strong{color:var(--accent)}

  /* Feedback overlay */
  .feedback{position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background:#00000088;z-index:100;opacity:0;pointer-events:none;transition:opacity .3s}
  .feedback.show{opacity:1;pointer-events:auto}
  .feedback-card{background:var(--card);border-radius:20px;padding:2rem;text-align:center;max-width:340px;width:90%;border:2px solid var(--accent);animation:pop .3s}
  .feedback-card h2{font-size:1.5rem;margin-bottom:.5rem}
  .feedback-card p{color:var(--muted);margin-bottom:1rem;font-size:.9rem;line-height:1.4}
  .feedback-card button{background:var(--accent);color:#0f172a;border:none;padding:.6rem 1.5rem;border-radius:10px;font-size:1rem;font-weight:600;cursor:pointer}
  .feedback-card button:active{transform:scale(.95)}
  @keyframes pop{from{transform:scale(.8);opacity:0}to{transform:scale(1);opacity:1}}

  /* Screens */
  .screen{display:none;flex-direction:column;align-items:center;width:100%;max-width:500px;padding:0 1rem}
  .screen.active{display:flex}

  /* Menu */
  .menu-btn{background:var(--accent);color:#0f172a;border:none;padding:.75rem 2rem;border-radius:12px;font-size:1.1rem;font-weight:700;cursor:pointer;margin:.5rem 0;width:80%;max-width:280px}
  .menu-btn:active{transform:scale(.95)}
  .menu-btn.secondary{background:transparent;color:var(--accent);border:2px solid var(--accent)}
  .menu-info{color:var(--muted);font-size:.8rem;text-align:center;margin-top:1rem;line-height:1.5;padding:0 1rem}

  /* Trophy */
  .trophy-row{display:flex;gap:.25rem;justify-content:center;margin:.5rem 0}
  .trophy-dot{width:28px;height:28px;border-radius:50%;background:var(--wire);display:flex;align-items:center;justify-content:center;font-size:.75rem;transition:all .3s}
  .trophy-dot.done{background:var(--on);color:#fff}
  .trophy-dot.current{background:var(--accent);color:#fff;animation:pulse-dot 1s infinite alternate}
  @keyframes pulse-dot{from{box-shadow:0 0 0 0 #38bdf844}to{box-shadow:0 0 0 8px #38bdf800}}

  /* Explanation box */
  .explain-box{background:#1a2332;border:1px solid #334155;border-radius:12px;padding:.75rem 1rem;margin:.5rem 0;width:min(95vw,460px);font-size:.82rem;line-height:1.5;color:var(--muted)}
  .explain-box strong{color:var(--text)}
  .explain-box code{background:#334155;padding:.1rem .3rem;border-radius:4px;color:var(--accent);font-size:.8rem}
</style>
</head>
<body>

<!-- MENU SCREEN -->
<div class="screen active" id="menuScreen">
  <h1>âš¡ <span>Circuito LÃ³gico</span></h1>
  <p class="subtitle">Aprenda lÃ³gica digital brincando!</p>
  <div style="font-size:4rem;margin:1.5rem 0">ğŸ”Œ</div>
  <button class="menu-btn" onclick="startGame()">â–¶ Jogar</button>
  <button class="menu-btn secondary" onclick="showTutorial()">â“ Como funciona</button>
  <p class="menu-info">
    Resolva circuitos com portas lÃ³gicas!<br>
    Alterne os interruptores para acender a lÃ¢mpada ğŸ’¡
  </p>
</div>

<!-- TUTORIAL SCREEN -->
<div class="screen" id="tutorialScreen">
  <h1>ğŸ“– Portas LÃ³gicas</h1>
  <p class="subtitle">As peÃ§as bÃ¡sicas dos computadores!</p>

  <div class="explain-box">
    <strong>AND (E)</strong> â€” SaÃ­da <code>1</code> sÃ³ quando <strong>todas</strong> as entradas sÃ£o <code>1</code>.<br>
    ğŸ”² 0 AND 0 = 0 &nbsp;|&nbsp; ğŸ”² 1 AND 0 = 0 &nbsp;|&nbsp; âœ… 1 AND 1 = 1
  </div>
  <div class="explain-box">
    <strong>OR (OU)</strong> â€” SaÃ­da <code>1</code> quando <strong>qualquer</strong> entrada Ã© <code>1</code>.<br>
    ğŸ”² 0 OR 0 = 0 &nbsp;|&nbsp; âœ… 1 OR 0 = 1 &nbsp;|&nbsp; âœ… 1 OR 1 = 1
  </div>
  <div class="explain-box">
    <strong>NOT (NÃƒO)</strong> â€” <strong>Inverte</strong> o sinal. <code>0</code> vira <code>1</code>, <code>1</code> vira <code>0</code>.<br>
    âœ… NOT 0 = 1 &nbsp;|&nbsp; ğŸ”² NOT 1 = 0
  </div>
  <div class="explain-box">
    <strong>XOR (OU-Exclusivo)</strong> â€” SaÃ­da <code>1</code> quando as entradas sÃ£o <strong>diferentes</strong>.<br>
    ğŸ”² 0 XOR 0 = 0 &nbsp;|&nbsp; âœ… 1 XOR 0 = 1 &nbsp;|&nbsp; ğŸ”² 1 XOR 1 = 0
  </div>

  <button class="menu-btn" onclick="showMenu()" style="margin-top:1rem">â¬… Voltar</button>
</div>

<!-- GAME SCREEN -->
<div class="screen" id="gameScreen">
  <div class="topbar">
    <div class="badge"><span class="icon">ğŸ§©</span> Fase <span id="levelNum">1</span>/10</div>
    <div class="badge"><span class="icon">â­</span> <span id="stars">0</span></div>
    <div class="badge"><span class="icon">â±</span> <span id="timer">120</span>s</div>
    <div class="badge" style="cursor:pointer" onclick="showMenu()"><span class="icon">ğŸ </span></div>
  </div>

  <div class="trophy-row" id="trophyRow"></div>

  <div class="goal" id="goalText"></div>

  <div class="circuit-wrap">
    <canvas id="circuitCanvas"></canvas>
  </div>

  <div class="switches" id="switchesRow"></div>

  <div class="output-row">
    <span class="bulb" id="bulb">ğŸ’¡</span>
    <span class="output-label" id="outputLabel">SaÃ­da: 0</span>
    <span class="target-badge" id="targetBadge">ğŸ¯ ?</span>
  </div>
</div>

<!-- WIN SCREEN -->
<div class="screen" id="winScreen">
  <h1>ğŸ† ParabÃ©ns!</h1>
  <p class="subtitle">VocÃª completou todos os circuitos!</p>
  <div style="font-size:4rem;margin:1rem 0">ğŸ‰</div>
  <p id="finalScore" style="font-size:1.2rem;margin-bottom:1rem"></p>
  <button class="menu-btn" onclick="startGame()">ğŸ”„ Jogar novamente</button>
  <button class="menu-btn secondary" onclick="showMenu()">ğŸ  Menu</button>
</div>

<!-- LEVEL COMPLETE OVERLAY -->
<div class="feedback" id="levelFeedback">
  <div class="feedback-card">
    <h2 id="fbTitle">âœ… Circuito resolvido!</h2>
    <p id="fbDesc"></p>
    <button onclick="nextLevel()">PrÃ³xima fase â–¶</button>
  </div>
</div>

<script>
// ========== LEVELS ==========
const LEVELS = [
  {
    name: "NOT simples",
    desc: "A porta NOT inverte o sinal. FaÃ§a a saÃ­da ser 0!",
    inputs: ["A"],
    initial: {"A": 1},
    gates: [{type:"NOT",in:["A"],out:"Y"}],
    output: "Y",
    target: 0,
    teach: "NOT inverte: se a entrada Ã© 1, a saÃ­da Ã© 0 (e vice-versa)."
  },
  {
    name: "OR simples",
    desc: "A porta OR liga quando qualquer entrada Ã© 1.",
    inputs: ["A","B"],
    gates: [{type:"OR",in:["A","B"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "OR (OU): basta uma entrada ser 1 para a saÃ­da ser 1."
  },
  {
    name: "AND simples",
    desc: "A porta AND sÃ³ liga quando TODAS as entradas sÃ£o 1.",
    inputs: ["A","B"],
    gates: [{type:"AND",in:["A","B"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "AND (E): todas as entradas precisam ser 1."
  },
  {
    name: "NOT + AND",
    desc: "Combine NOT e AND. Ache a combinaÃ§Ã£o que acende!",
    inputs: ["A","B"],
    gates: [{type:"NOT",in:["A"],out:"notA"},{type:"AND",in:["notA","B"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "NOT(A) AND B = 1 quando A=0 e B=1. O NOT inverte A antes do AND."
  },
  {
    name: "XOR â€” Ou-Exclusivo",
    desc: "XOR liga quando as entradas sÃ£o DIFERENTES.",
    inputs: ["A","B"],
    gates: [{type:"XOR",in:["A","B"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "XOR: saÃ­da 1 quando as entradas sÃ£o diferentes (uma 0 e outra 1)."
  },
  {
    name: "OR + NOT (NOR)",
    desc: "OR seguido de NOT. Quando a saÃ­da acende?",
    inputs: ["A","B"],
    gates: [{type:"OR",in:["A","B"],out:"mid"},{type:"NOT",in:["mid"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "NOT(A OR B) = 1 somente quando ambas entradas sÃ£o 0. Isso Ã© a porta NOR!"
  },
  {
    name: "TrÃªs entradas",
    desc: "TrÃªs interruptores! Use AND e OR juntos.",
    inputs: ["A","B","C"],
    gates: [{type:"AND",in:["A","B"],out:"ab"},{type:"OR",in:["ab","C"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "(A AND B) OR C = 1 se C=1, ou se A e B sÃ£o ambos 1."
  },
  {
    name: "XOR duplo",
    desc: "Dois XORs encadeados. Pense com calma!",
    inputs: ["A","B","C"],
    gates: [{type:"XOR",in:["A","B"],out:"ab"},{type:"XOR",in:["ab","C"],out:"Y"}],
    output: "Y",
    target: 1,
    teach: "XOR encadeado conta se hÃ¡ nÃºmero ÃMPAR de 1s entre as entradas."
  },
  {
    name: "NAND â€” NOT + AND",
    desc: "AND invertido! Qual combinaÃ§Ã£o NÃƒO acende?",
    inputs: ["A","B"],
    gates: [{type:"AND",in:["A","B"],out:"mid"},{type:"NOT",in:["mid"],out:"Y"}],
    output: "Y",
    target: 0,
    teach: "NAND = NOT(AND). A Ãºnica combinaÃ§Ã£o que dÃ¡ 0 Ã© A=1 e B=1."
  },
  {
    name: "Desafio final",
    desc: "Circuito complexo! Use tudo que aprendeu.",
    inputs: ["A","B","C"],
    gates: [
      {type:"NOT",in:["A"],out:"notA"},
      {type:"AND",in:["notA","B"],out:"m1"},
      {type:"XOR",in:["B","C"],out:"m2"},
      {type:"OR",in:["m1","m2"],out:"Y"}
    ],
    output: "Y",
    target: 1,
    teach: "NOT(A) AND B) OR (B XOR C). Muitas combinaÃ§Ãµes funcionam â€” o segredo Ã© testar!"
  }
];

// ========== STATE ==========
let currentLevel = 0;
let inputs = {};
let starsCount = 0;
let attempts = 0;
let timeLeft = 120;
let timer = null;

// ========== NAVIGATION ==========
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function showMenu() {
  if (timer) { clearInterval(timer); timer = null; }
  showScreen('menuScreen');
}
function showTutorial() { showScreen('tutorialScreen'); }

function startGame() {
  currentLevel = 0;
  starsCount = 0;
  timeLeft = 120;
  document.getElementById('stars').textContent = '0';
  document.getElementById('timer').textContent = timeLeft;
  if (timer) clearInterval(timer);
  timer = setInterval(() => {
    timeLeft--;
    document.getElementById('timer').textContent = Math.max(0, timeLeft);
    if (timeLeft <= 0) {
      clearInterval(timer);
      timer = null;
      currentLevel = LEVELS.length;
      nextLevel();
    }
  }, 1000);
  showScreen('gameScreen');
  loadLevel();
}

// ========== LEVEL LOADING ==========
function loadLevel() {
  const lvl = LEVELS[currentLevel];
  attempts = 0;
  inputs = {};
  lvl.inputs.forEach(i => inputs[i] = null);

  document.getElementById('levelNum').textContent = currentLevel + 1;
  const targetHint = lvl.target === 0
    ? '<br>ğŸ¯ Objetivo: fazer a saÃ­da ser <strong style="color:#ef4444">0 (desligada)</strong>!'
    : '<br>ğŸ¯ Objetivo: fazer a saÃ­da ser <strong style="color:#22c55e">1 (ligada)</strong>!';
  document.getElementById('goalText').innerHTML = `<strong>${lvl.name}</strong><br>${lvl.desc}${targetHint}`;
  document.getElementById('targetBadge').textContent = lvl.target === 1 ? 'ğŸ¯ â†’ 1' : 'ğŸ¯ â†’ 0';

  // Trophy row
  const tr = document.getElementById('trophyRow');
  tr.innerHTML = '';
  for (let i = 0; i < LEVELS.length; i++) {
    const d = document.createElement('div');
    d.className = 'trophy-dot' + (i < currentLevel ? ' done' : '') + (i === currentLevel ? ' current' : '');
    d.textContent = i < currentLevel ? 'âœ“' : (i + 1);
    tr.appendChild(d);
  }

  // Switches
  const sr = document.getElementById('switchesRow');
  sr.innerHTML = '';
  lvl.inputs.forEach(name => {
    const g = document.createElement('div');
    g.className = 'switch-group';
    g.innerHTML = `<span class="switch-label">${name}</span>`;
    const btn = document.createElement('button');
    btn.className = 'switch-btn indeterminate';
    btn.textContent = '-';
    btn.onclick = () => toggleInput(name, btn);
    g.appendChild(btn);
    sr.appendChild(g);
  });

  evaluate();
  drawCircuit();
}

function toggleInput(name, btn) {
  if (inputs[name] === null) inputs[name] = 0;
  else inputs[name] = inputs[name] === 0 ? 1 : 0;

  btn.textContent = inputs[name] === null ? '-' : String(inputs[name]);
  btn.classList.toggle('indeterminate', inputs[name] === null);
  btn.classList.toggle('on', inputs[name] === 1);

  evaluate();
  drawCircuit();
}

// ========== EVALUATE ==========
function evaluate() {
  const lvl = LEVELS[currentLevel];
  const vals = { ...inputs };

  for (const g of lvl.gates) {
    const a = vals[g.in[0]];
    const b = g.in.length > 1 ? vals[g.in[1]] : undefined;

    if (a == null || (g.in.length > 1 && b == null)) {
      vals[g.out] = null;
      continue;
    }

    switch(g.type) {
      case 'NOT': vals[g.out] = a === 1 ? 0 : 1; break;
      case 'AND': vals[g.out] = (a === 1 && b === 1) ? 1 : 0; break;
      case 'OR':  vals[g.out] = (a === 1 || b === 1) ? 1 : 0; break;
      case 'XOR': vals[g.out] = (a !== b) ? 1 : 0; break;
    }
  }

  const result = vals[lvl.output];
  const bulb = document.getElementById('bulb');
  const label = document.getElementById('outputLabel');

  if (result == null) {
    bulb.textContent = 'â”';
    bulb.classList.remove('lit');
    label.textContent = 'SaÃ­da: -';
    label.className = 'output-label off';
    return;
  }

  bulb.textContent = result === 1 ? 'ğŸ’¡' : 'ğŸ”Œ';
  bulb.classList.toggle('lit', result === 1);
  label.textContent = `SaÃ­da: ${result}`;
  label.className = 'output-label ' + (result === 1 ? 'on' : 'off');

  // Check win
  attempts++;
  if (attempts > 1 && result === lvl.target) {
    setTimeout(() => showLevelComplete(lvl), 400);
  }
}

function showLevelComplete(lvl) {
  starsCount++;
  document.getElementById('stars').textContent = starsCount;
  document.getElementById('fbTitle').textContent = currentLevel === LEVELS.length - 1 ? 'ğŸ† Desafio final completo!' : 'âœ… Circuito resolvido!';
  document.getElementById('fbDesc').innerHTML = `<strong>ğŸ’¡ ${lvl.teach}</strong>`;

  if (currentLevel === LEVELS.length - 1) {
    document.getElementById('fbDesc').innerHTML += '<br><br>VocÃª dominou as portas lÃ³gicas!';
  }

  document.getElementById('levelFeedback').classList.add('show');
}

function nextLevel() {
  document.getElementById('levelFeedback').classList.remove('show');
  currentLevel++;
  if (currentLevel >= LEVELS.length) {
    if (timer) { clearInterval(timer); timer = null; }
    const timeBonus = Math.max(0, timeLeft) * 2;
    const finalScore = starsCount * 10 + timeBonus;
    document.getElementById('finalScore').textContent = `â­ ${starsCount} estrelas + bÃ´nus tempo ${timeBonus} = ${finalScore} pts`;
    try {
      window.parent.postMessage({ type: 'game-score', game: 'circuito', score: finalScore }, '*');
    } catch (err) {
      console.warn('NÃ£o foi possÃ­vel enviar pontuaÃ§Ã£o para o hub', err);
    }
    showScreen('winScreen');
  } else {
    loadLevel();
  }
}

// ========== DRAW CIRCUIT ==========
function drawCircuit() {
  const canvas = document.getElementById('circuitCanvas');
  const wrap = canvas.parentElement;
  const W = wrap.clientWidth * 2;
  const H = wrap.clientHeight * 2;
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, W, H);

  const lvl = LEVELS[currentLevel];
  const vals = {...inputs};

  // Compute all values
  const gateVals = [];
  for (const g of lvl.gates) {
    const a = vals[g.in[0]];
    const b = g.in.length > 1 ? vals[g.in[1]] : undefined;
    let r = null;

    if (a != null && (g.in.length === 1 || b != null)) {
      switch(g.type) {
        case 'NOT': r = a === 1 ? 0 : 1; break;
        case 'AND': r = (a === 1 && b === 1) ? 1 : 0; break;
        case 'OR':  r = (a === 1 || b === 1) ? 1 : 0; break;
        case 'XOR': r = (a !== b) ? 1 : 0; break;
      }
    }

    vals[g.out] = r;
    gateVals.push(r);
  }

  const numGates = lvl.gates.length;
  const numInputs = lvl.inputs.length;

  // Layout: inputs on left, gates in middle columns, output on right
  const leftX = W * 0.1;
  const rightX = W * 0.9;
  const gateW = 100;
  const gateH = 60;

  // Position inputs evenly on left
  const inputPositions = {};
  lvl.inputs.forEach((name, i) => {
    const y = H * (i + 1) / (numInputs + 1);
    inputPositions[name] = {x: leftX, y};
  });

  // Position gates in columns
  const nodePositions = {...inputPositions};
  const gatePositions = [];

  // Simple layout: spread gates horizontally
  const gateStartX = W * 0.35;
  const gateEndX = W * 0.75;
  const gateSpanX = numGates > 1 ? (gateEndX - gateStartX) / (numGates - 1) : 0;

  lvl.gates.forEach((g, i) => {
    const x = numGates === 1 ? (gateStartX + gateEndX) / 2 : gateStartX + gateSpanX * i;
    // Y: average of input positions
    let ySum = 0;
    g.in.forEach(inp => { ySum += (nodePositions[inp]?.y || H/2); });
    const y = ySum / g.in.length;
    gatePositions.push({x, y});
    nodePositions[g.out] = {x: x + gateW/2 + 10, y};
  });

  const outputPos = {x: rightX, y: H / 2};

  // Draw wires
  function drawWire(from, to, active) {
    ctx.beginPath();
    ctx.strokeStyle = active ? '#38bdf8' : '#334155';
    ctx.lineWidth = active ? 5 : 3;
    ctx.shadowColor = active ? '#38bdf8' : 'transparent';
    ctx.shadowBlur = active ? 12 : 0;

    // Simple bezier
    const mx = (from.x + to.x) / 2;
    ctx.moveTo(from.x, from.y);
    ctx.bezierCurveTo(mx, from.y, mx, to.y, to.x, to.y);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Draw all wires: input/gate â†’ gate inputs, and last gate â†’ output
  lvl.gates.forEach((g, gi) => {
    const gp = gatePositions[gi];
    g.in.forEach((inp, ii) => {
      const from = nodePositions[inp];
      const yOff = g.in.length > 1 ? (ii === 0 ? -15 : 15) : 0;
      const to = {x: gp.x - gateW/2, y: gp.y + yOff};
      drawWire(from, to, vals[inp]);
    });
  });

  // Draw output wire from last gate
  const lastGP = gatePositions[gatePositions.length - 1];
  drawWire(
    {x: lastGP.x + gateW/2, y: lastGP.y},
    outputPos,
    vals[lvl.output]
  );

  // Draw input nodes
  lvl.inputs.forEach(name => {
    const p = inputPositions[name];
    const val = inputs[name];
    const isOn = val === 1;
    const isUndefined = val == null;

    ctx.beginPath();
    ctx.arc(p.x, p.y, 18, 0, Math.PI * 2);
    ctx.fillStyle = isUndefined ? '#1f2937' : (isOn ? '#22c55e' : '#475569');
    ctx.fill();
    ctx.strokeStyle = isUndefined ? '#94a3b8' : (isOn ? '#4ade80' : '#64748b');
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(isUndefined ? '-' : String(val), p.x, p.y);

    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '18px sans-serif';
    ctx.fillText(name, p.x, p.y - 32);
  });

  // Draw gates
  lvl.gates.forEach((g, gi) => {
    const p = gatePositions[gi];
    const active = gateVals[gi];

    // Gate box
    ctx.beginPath();
    ctx.roundRect(p.x - gateW/2, p.y - gateH/2, gateW, gateH, 12);
    ctx.fillStyle = active ? '#1e3a5f' : '#1e293b';
    ctx.fill();
    ctx.strokeStyle = active ? '#38bdf8' : '#475569';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Gate label
    ctx.fillStyle = active ? '#38bdf8' : '#94a3b8';
    ctx.font = 'bold 22px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(g.type, p.x, p.y);
  });

  // Draw output bulb
  ctx.beginPath();
  ctx.arc(outputPos.x, outputPos.y, 24, 0, Math.PI * 2);
  const outVal = vals[lvl.output];
  const outUndefined = outVal == null;

  ctx.fillStyle = outUndefined ? '#1f2937' : (outVal === 1 ? '#fbbf24' : '#475569');
  ctx.fill();
  if (outVal === 1) {
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  ctx.strokeStyle = outUndefined ? '#94a3b8' : (outVal === 1 ? '#f59e0b' : '#64748b');
  ctx.lineWidth = 3;
  ctx.stroke();

  ctx.fillStyle = outVal === 1 ? '#000' : '#fff';
  ctx.font = '20px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(outUndefined ? '-' : String(outVal), outputPos.x, outputPos.y);
}

// Resize handler
window.addEventListener('resize', () => {
  if (document.getElementById('gameScreen').classList.contains('active')) {
    drawCircuit();
  }
});
</script>
</body>
</html>
